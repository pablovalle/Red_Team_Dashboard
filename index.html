<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
      body { 
        margin: 0; 
        padding: 20px; 
        font-family: Arial, sans-serif;
        background: #f8f9fa;
      }
      .container { 
        max-width: 1400px; 
        margin: 0 auto; 
      }
      .ranking-box h2 {
        font-weight: 800;
      }
      .metrics-container { 
        display: grid; 
        grid-template-columns: repeat(3, 1fr); 
        gap: 25px; 
        margin-bottom: 30px;
      }
      .metric-box { 
        background: white;
        padding: 25px; 
        border-radius: 12px; 
        text-align: center;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        transition: transform 0.2s;
        border: 1px solid rgba(0,0,0,0.1);
        min-height: 200px;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      .metric-box:hover {
        transform: translateY(-5px);
      }
      .metric-box h2 {
        margin: 0 0 15px 0;
        color: #2c3e50;
        font-size: 2em;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }
      .counter {
        font-size: 3.5em;
        font-weight: bold;
        margin: 10px 0;
      }
      .metric-icon {
        font-size: 2em;
        margin-bottom: 15px;
      }
      .pass-box { 
        background: linear-gradient(135deg, #d4edda 0%, #ffffff 100%);
        border-left: 5px solid #28a745;
      }
      .pass-box .counter { color: #28a745; }
      
      .fail-box { 
        background: linear-gradient(135deg, #f8d7da 0%, #ffffff 100%);
        border-left: 5px solid #dc3545;
      }
      .fail-box .counter { color: #dc3545; }
      
      .ranking-box { 
        background: linear-gradient(135deg, #fff3cd 0%, #ffffff 100%);
        border-left: 5px solid #ffc107;
      }
      .ranking-box .counter { color: #ffc107; }

      /* Horizontal bar styles */
      .metric-row {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .metric-label {
        width: 60px; 
        text-align: right;
        margin-right: 10px;
        font-weight: bold;
      }
      .progress-bar {
        flex: 1;
        background-color: #eee;
        border-radius: 4px;
        height: 12px;
        position: relative;
        overflow: hidden;
      }
      .progress {
        height: 100%;
        border-radius: 4px;
      }
      .progress-pass {
        background-color: #28a745;
      }
      .progress-fail {
        background-color: #dc3545;
      }

      .charts-row {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
        margin: 20px 0;
      }
      
      .chart-wrapper {
        background: white;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        height: 400px;
      }
      
      .chart-title {
        margin: 0 0 10px 0;
        font-size: 1.1em;
        color: #333;
      }
      
      canvas {
        max-height: 350px !important;
      }
      
      table { 
        width: 100%; 
        margin: 15px 0; 
        border-collapse: collapse; 
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        background: white;
        border-radius: 8px;
        overflow: hidden;
      }
      
      th, td { 
        padding: 12px; 
        border: 1px solid #eee;
        text-align: right;
      }
      .td2{
        text-align: left;
      }
      
      th { 
        background: #f8f9fa; 
        font-weight: 600;
        color: #333;
        text-align: center;
      }
      
      tr:nth-child(even) { background: #f9f9f9; }
      tr:hover { background: #f5f5f5; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Red Teaming Dashboard</h1>

      <div class="metrics-container">
        <!-- Caja 1: Total PASS -->
        <div class="metric-box pass-box">
          <h2>Total PASS <div class="metric-icon">✓</div></h2>
          <div id="totalPass" class="counter">0</div>
        </div>

        <!-- Caja 2: Total FAIL -->
        <div class="metric-box fail-box">
          <h2>Total FAIL <div class="metric-icon">✗</div></h2>
          <div id="totalFail" class="counter">0</div>
        </div>

        <!-- Caja 3: Global Results with horizontal bars -->
        <div class="metric-box ranking-box">
          <h2>Global Results</h2>
          <!-- Barra de PASS -->
          <div class="metric-row">
            <span class="metric-label" id="passLabel">PASS: 0%</span>
            <div class="progress-bar">
              <div class="progress progress-pass" id="passBar" style="width: 0%;"></div>
            </div>
          </div>
          <!-- Barra de FAIL -->
          <div class="metric-row">
            <span class="metric-label" id="failLabel">FAIL: 0%</span>
            <div class="progress-bar">
              <div class="progress progress-fail" id="failBar" style="width: 0%;"></div>
            </div>
          </div>
        </div>
      </div>

      <h2>Stats for each User</h2>
      <table id="userClassification">
        <thead>
          <tr>
            <th>User</th>
            <th>PASS</th>
            <th>FAIL Low</th>
            <th>FAIL Medium</th>
            <th>FAIL High</th>
            <th>FAIL Critical</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

      <div class="charts-row">
        <div class="chart-wrapper">
          <h3 class="chart-title">PASS/FAIL for User</h3>
          <canvas id="userPassFailChart"></canvas>
        </div>
        <div class="chart-wrapper">
          <h3 class="chart-title">Tests for each Model and User</h3>
          <canvas id="userModelChart"></canvas>
        </div>
      </div>

      <div class="charts-row">
        <div class="chart-wrapper">
          <h3 class="chart-title">Safety Categories</h3>
          <canvas id="categoriesChart"></canvas>
        </div>
        <div class="chart-wrapper">
          <h3 class="chart-title">Languages</h3>
          <canvas id="LanguageScoreChart"></canvas>
        </div>
      </div>

      <div class="charts-row">
        <div class="chart-wrapper">
          <h3 class="chart-title">PASS/FAIL for Model</h3>
          <canvas id="modelPassFailChart"></canvas>
        </div>
        <div class="chart-wrapper">
          <h3 class="chart-title">FAIL per Category and Model</h3>
          <canvas id="categoryModelFailChart"></canvas>
        </div>
      </div>
    </div>

    <script>
      // Cache DOM elements
      const elements = {
        totalPass: document.getElementById('totalPass'),
        totalFail: document.getElementById('totalFail'),
        passLabel: document.getElementById('passLabel'),
        failLabel: document.getElementById('failLabel'),
        passBar: document.getElementById('passBar'),
        failBar: document.getElementById('failBar'),
        tbody: document.querySelector('#userClassification tbody')
      };
      
      // Charts cache
      const charts = {};
      
      // Constants
      const REFRESH_INTERVAL = 5000; // Changed from 1000ms to 5000ms
      const DATA_URL = "https://script.google.com/a/macros/mondragon.edu/s/AKfycbwmjfrXu08q-jzHROM99LUV6hO7egw4Dr6zAzWihd-OTZfS9LkmQc9TEEBu4DOqBhMTqw/exec?getData=true";
      const MODEL_COLORS = {
        'chatgpt': '#00A67E',
        'gpt4-o': '#4A90E2',
        'claude': '#7B61FF',
        'qwen': '#1EA362',
        'llama': '#FF6B6B',
        'mistral': '#FFB347',
        'default': '#999999'
      };
      
      const FAIL_POINTS = {
        low: 1,
        medium: 2,
        high: 3,
        critical: 4
      };
      
      // Cache last data to avoid unnecessary redraws
      let lastData = null;
      
      // Detect fail level once
      function getFailLevel(notes) {
        if (!notes) return 'low';
        notes = notes.toLowerCase();
        if (notes.includes('critical')) return 'critical';
        if (notes.includes('high')) return 'high';
        if (notes.includes('medium')) return 'medium';
        return 'low';
      }

      // Process data more efficiently
      function processData(data) {
        const result = {
          totalPass: 0,
          totalFail: 0,
          users: {},
          categories: {},
          models: {},
          languages: {},
          categoryModels: {}
        };

        // Iterate once through the data
        data.forEach(row => {
          if(row.length < 8) return;

          const user = row[1];
          const model = row[2];
          const lang = row[3];
          const category = row[4];
          const resultStr = row[6].toLowerCase();
          const notes = row[7];
          const failLevel = getFailLevel(notes);

          // Initialize objects on first encounter (using logical OR for simplicity)
          result.users[user] = result.users[user] || {
            pass: 0,
            failLow: 0,
            failMedium: 0,
            failHigh: 0,
            failCritical: 0,
            score: 0,
            models: {}
          };
          
          result.categories[category] = result.categories[category] || { pass: 0, fail: 0 };
          result.languages[lang] = result.languages[lang] || { pass: 0, fail: 0 };
          result.models[model] = result.models[model] || { pass: 0, fail: 0 };
          result.users[user].models[model] = result.users[user].models[model] || 0;
          result.users[user].models[model]++;
          
          // Process PASS/FAIL counts
          if(resultStr === 'pass') {
            result.totalPass++;
            result.users[user].pass++;
            result.users[user].score += 1;
            result.categories[category].pass++;
            result.languages[lang].pass++;
            result.models[model].pass++;
          } else if (resultStr === 'fail') {
            result.totalFail++;
            result.users[user]['fail' + failLevel.charAt(0).toUpperCase() + failLevel.slice(1)]++;
            result.users[user].score += FAIL_POINTS[failLevel] || 1;
            result.categories[category].fail++;
            result.languages[lang].fail++;
            result.models[model].fail++;
            
            // Category-model tracking for FAIL
            result.categoryModels[category] = result.categoryModels[category] || {};
            result.categoryModels[category][model] = (result.categoryModels[category][model] || 0) + 1;
          }
        });

        return result;
      }

      // Update UI efficiently with cached elements
      function updateUI({ totalPass, totalFail, users }) {
        const total = totalPass + totalFail || 1;
        const passPercent = ((totalPass / total) * 100).toFixed(2);
        const failPercent = ((totalFail / total) * 100).toFixed(2);

        elements.totalPass.textContent = totalPass;
        elements.totalFail.textContent = totalFail;
        elements.passLabel.textContent = `PASS: ${passPercent}%`;
        elements.failLabel.textContent = `FAIL: ${failPercent}%`;
        elements.passBar.style.width = `${passPercent}%`;
        elements.failBar.style.width = `${failPercent}%`;

        // Sort users once and build table HTML in memory
        const sortedUsers = Object.entries(users)
          .sort(([, a], [, b]) => {
            const sumA = a.pass + a.failLow + a.failMedium + a.failHigh + a.failCritical;
            const sumB = b.pass + b.failLow + b.failMedium + b.failHigh + b.failCritical;
            return sumB - sumA;
          });

        // Build HTML in memory before inserting into DOM
        const tableHTML = sortedUsers.map(([user, data]) => `
          <tr>
            <td class="td2">${user}</td>
            <td>${data.pass}</td>
            <td>${data.failLow}</td>
            <td>${data.failMedium}</td>
            <td>${data.failHigh}</td>
            <td>${data.failCritical}</td>
          </tr>
        `).join('');
        
        elements.tbody.innerHTML = tableHTML;
      }

      // Update charts with improved data handling
      function updateCharts(data) {
        // Common data preparation (do this once)
        const users = Object.keys(data.users);
        const languages = Object.keys(data.languages);
        const categories = Object.keys(data.categories);
        const modelNames = Object.keys(data.models);
        const categoryNames = Object.keys(data.categoryModels);
        
        // Pre-calculate all needed dataset values
        const userPassData = users.map(user => data.users[user].pass);
        const userFailData = users.map(user => 
          data.users[user].failLow + 
          data.users[user].failMedium + 
          data.users[user].failHigh + 
          data.users[user].failCritical
        );
        
        // Find unique models across all users
        const allModels = [...new Set(
          Object.values(data.users)
            .flatMap(user => Object.keys(user.models))
        )];
        
        // Pre-calculate maximums for scales
        const maxLang = Math.max(
          ...Object.values(data.languages).map(lang => Math.max(lang.pass, lang.fail))
        );
        
        const maxModelValue = Math.max(
          ...allModels.map(model => Math.max(...users.map(user => data.users[user].models[model] || 0))),
          1
        );
        
        const maxCategoryValue = Math.max(
          ...Object.values(data.categories).map(cat => Math.max(cat.pass, cat.fail))
        );
        
        const maxModelPassFail = Math.max(
          ...modelNames.map(m => Math.max(data.models[m].pass, data.models[m].fail))
        );
        
        // Build all chart configurations up front
        const chartConfigs = {
          'LanguageScoreChart': {
            type: 'bar',
            data: {
              labels: languages,
              datasets: [
                {
                  label: 'PASS',
                  data: languages.map(lang => data.languages[lang].pass),
                  backgroundColor: '#75b798'
                },
                {
                  label: 'FAIL',
                  data: languages.map(lang => data.languages[lang].fail),
                  backgroundColor: '#e35d6a'
                }
              ]
            },
            options: {
              animation: false,
              responsive: true,
              maintainAspectRatio: false,
              plugins: { legend: { display: true } },
              scales: { y: { beginAtZero: true, max: maxLang + 2 } }
            }
          },
          'userPassFailChart': {
            type: 'bar',
            data: {
              labels: users,
              datasets: [
                {
                  label: 'PASS',
                  data: userPassData,
                  backgroundColor: '#75b798'
                },
                {
                  label: 'FAIL',
                  data: userFailData,
                  backgroundColor: '#e35d6a'
                }
              ]
            },
            options: {
              animation: false,
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: { stacked: true },
                y: { stacked: true, beginAtZero: true, max: maxModelValue + 2 }
              }
            }
          },
          'userModelChart': {
            type: 'bar',
            data: {
              labels: users,
              datasets: allModels.map(model => ({
                label: model,
                data: users.map(user => data.users[user].models[model] || 0),
                backgroundColor: MODEL_COLORS[model.toLowerCase()] || MODEL_COLORS.default
              }))
            },
            options: {
              animation: false,
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: { stacked: true },
                y: { stacked: true, beginAtZero: true, max: maxModelValue + 2 }
              }
            }
          },
          'categoriesChart': {
            type: 'bar',
            data: {
              labels: categories,
              datasets: [
                {
                  label: 'PASS',
                  data: categories.map(cat => data.categories[cat].pass),
                  backgroundColor: '#75b798'
                },
                {
                  label: 'FAIL',
                  data: categories.map(cat => data.categories[cat].fail),
                  backgroundColor: '#e35d6a'
                }
              ]
            },
            options: {
              animation: false,
              responsive: true,
              maintainAspectRatio: false,
              scales: { y: { beginAtZero: true, max: maxCategoryValue + 2 } }
            }
          },
          'modelPassFailChart': {
            type: 'bar',
            data: {
              labels: modelNames,
              datasets: [
                {
                  label: 'PASS',
                  data: modelNames.map(m => data.models[m].pass),
                  backgroundColor: '#28a745'
                },
                {
                  label: 'FAIL',
                  data: modelNames.map(m => data.models[m].fail),
                  backgroundColor: '#dc3545'
                }
              ]
            },
            options: {
              animation: false,
              responsive: true,
              maintainAspectRatio: false,
              plugins: { legend: { display: true } },
              scales: { y: { beginAtZero: true, max: maxModelPassFail + 2 } }
            }
          }
        };
        
        // Build category model chart separately as it's more complex
        const modelSet = new Set();
        categoryNames.forEach(cat => {
          Object.keys(data.categoryModels[cat]).forEach(model => modelSet.add(model));
        });
        const allCatModels = Array.from(modelSet);
        
        const maxIndividualFail = Math.max(...categoryNames.map(cat => {
          return Math.max(...allCatModels.map(model => data.categoryModels[cat][model] || 0));
        }), 0);
        
        chartConfigs['categoryModelFailChart'] = {
          type: 'bar',
          data: {
            labels: categoryNames,
            datasets: allCatModels.map(model => ({
              label: model,
              data: categoryNames.map(cat => data.categoryModels[cat][model] || 0),
              backgroundColor: MODEL_COLORS[model.toLowerCase()] || MODEL_COLORS.default
            }))
          },
          options: {
            animation: false,
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: true } },
            scales: {
              x: { stacked: false },
              y: { beginAtZero: true, max: maxIndividualFail + 2 }
            }
          }
        };
        
        // Update all charts at once
        Object.entries(chartConfigs).forEach(([id, config]) => {
          updateOrCreateChart(id, config);
        });
      }

      // Optimized chart update function with lazy initialization
      function updateOrCreateChart(id, config) {
        if (charts[id]) {
          charts[id].data = config.data;
          charts[id].options = config.options;
          charts[id].update();
        } else {
          charts[id] = new Chart(document.getElementById(id), config);
        }
      }

      // Fetch data with debouncing and caching
      let fetchInProgress = false;
      async function refreshData() {
        if (fetchInProgress) return;
        
        fetchInProgress = true;
        try {
          const response = await fetch(DATA_URL);
          const rawData = await response.json();

          if (rawData.error) throw new Error(rawData.error);

          const processed = processData(rawData);
          
          // Compare with last data to avoid unnecessary updates
          const dataChanged = !lastData || 
            lastData.totalPass !== processed.totalPass || 
            lastData.totalFail !== processed.totalFail;
            
          if (dataChanged) {
            updateUI(processed);
            updateCharts(processed);
            lastData = processed;
          }
        } catch(error) {
          console.error('Error:', error);
        } finally {
          fetchInProgress = false;
        }
      }

      // Initialize and start periodic refresh
      document.addEventListener('DOMContentLoaded', () => {
        refreshData();
        // Use more efficient setInterval with longer duration
        setInterval(refreshData, REFRESH_INTERVAL);
      });
    </script>
  </body>
</html>
